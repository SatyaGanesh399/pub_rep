"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n          case 2:\n            matchers = _context8.sent;\n\n            if (matchers) {\n              _context8.next = 5;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 5:\n            _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n            cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n\n            return _context8.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = _slicedToArray(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = _slicedToArray(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig:  false ? 0 : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _matchesMiddleware(options);\n\n          case 2:\n            matches = _context9.sent;\n\n            if (!(!matches || !options.fetchData)) {\n              _context9.next = 5;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", null);\n\n          case 5:\n            _context9.prev = 5;\n            _context9.next = 8;\n            return options.fetchData();\n\n          case 8:\n            data = _context9.sent;\n            _context9.next = 11;\n            return getMiddlewareData(data.dataHref, data.response, options);\n\n          case 11:\n            effect = _context9.sent;\n            return _context9.abrupt(\"return\", {\n              dataHref: data.dataHref,\n              json: data.json,\n              response: data.response,\n              text: data.text,\n              cacheKey: data.cacheKey,\n              effect: effect\n            });\n\n          case 15:\n            _context9.prev = 15;\n            _context9.t0 = _context9[\"catch\"](5);\n            return _context9.abrupt(\"return\", null);\n\n          case 18:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\"),\n          BloomFilter = _require.BloomFilter;\n\n      var staticFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n      var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (false) {}\n\n                matchesBflStatic = false;\n                matchesBflDynamic = false;\n                _i = 0, _arr = [as, resolvedAs];\n\n              case 4:\n                if (!(_i < _arr.length)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                curAs = _arr[_i];\n\n                if (!curAs) {\n                  _context.next = 32;\n                  break;\n                }\n\n                asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n                if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                  _context.next = 32;\n                  break;\n                }\n\n                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n              case 12:\n                if (!(_i2 < _arr2.length)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                normalizedAS = _arr2[_i2];\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                curAsParts = normalizedAS.split(\"/\");\n                i = 0;\n\n              case 16:\n                if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                currentPart = curAsParts.slice(0, i).join(\"/\");\n\n                if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart)))) {\n                  _context.next = 21;\n                  break;\n                }\n\n                matchesBflDynamic = true;\n                return _context.abrupt(\"break\", 24);\n\n              case 21:\n                i++;\n                _context.next = 16;\n                break;\n\n              case 24:\n                _i2++;\n                _context.next = 12;\n                break;\n\n              case 27:\n                if (!(matchesBflStatic || matchesBflDynamic)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!skipNavigate) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 30:\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                  router: this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 32:\n                _i++;\n                _context.next = 4;\n                break;\n\n              case 35:\n                return _context.abrupt(\"return\", false);\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if ((0, _islocalurl.isLocalURL)(url)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h === 1;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this._bfl(as, undefined, options.locale);\n\n              case 7:\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = this.isReady !== true;\n                this.isReady = true;\n                isSsr = this.isSsr;\n\n                if (!isQueryUpdating) {\n                  this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && this.clc)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n                prevLocale = nextState.locale;\n\n                if (true) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === \"undefined\") {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n                localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                  as = (0, _formaturl.formatWithValidation)(parsedAs);\n                  url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 28:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark(\"routeChange\");\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (this._inFlightRoute && this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                  }\n\n                  this.clc();\n                  this.clc = null;\n                }\n\n                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context2.next = 52;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  this.scrollToHash(cleanedAs);\n                }\n\n                _context2.prev = 41;\n                _context2.next = 44;\n                return this.set(nextState, this.components[nextState.route], null);\n\n              case 44:\n                _context2.next = 50;\n                break;\n\n              case 46:\n                _context2.prev = 46;\n                _context2.t0 = _context2[\"catch\"](41);\n\n                if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n                }\n\n                throw _context2.t0;\n\n              case 50:\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return _context2.abrupt(\"return\", true);\n\n              case 52:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n                // trigger hard navigation\n\n                if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                  _context2.next = 57;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 57:\n                _context2.prev = 57;\n                _context2.next = 60;\n                return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n              case 60:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context2.next = 70;\n                break;\n\n              case 66:\n                _context2.prev = 66;\n                _context2.t1 = _context2[\"catch\"](57);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 70:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = \"replaceState\";\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context2.t2 = !options.shallow;\n\n                if (!_context2.t2) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                _context2.next = 80;\n                return _matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: this\n                });\n\n              case 80:\n                _context2.t2 = _context2.sent;\n\n              case 81:\n                isMiddlewareMatch = _context2.t2;\n\n                if (isQueryUpdating && isMiddlewareMatch) {\n                  shouldResolveHref = false;\n                }\n\n                if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                  _context2.next = 96;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (true) {\n                  _context2.next = 94;\n                  break;\n                }\n\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context2.next = 90;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", true);\n\n              case 90:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                _context2.next = 96;\n                break;\n\n              case 94:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 96:\n                if ((0, _islocalurl.isLocalURL)(as)) {\n                  _context2.next = 101;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 99:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 101:\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                routeMatch = false;\n\n                if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                  _context2.next = 119;\n                  break;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeregex.getRouteRegex)(route);\n                routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context2.next = 118;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param] && !routeRegex.groups[param].optional;\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context2.next = 116;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n              case 116:\n                _context2.next = 119;\n                break;\n\n              case 118:\n                if (shouldInterpolate) {\n                  as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 119:\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeStart\", as, routeProps);\n                }\n\n                isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n                _context2.prev = 121;\n                _context2.next = 124;\n                return this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch,\n                  unstable_skipClientCache: options.unstable_skipClientCache,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback,\n                  isMiddlewareRewrite: isMiddlewareRewrite\n                });\n\n              case 124:\n                routeInfo = _context2.sent;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 128;\n                  break;\n                }\n\n                _context2.next = 128;\n                return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n              case 128:\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                      rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n\n                    if (false) {}\n\n                    _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 136;\n                  break;\n                }\n\n                if (!(routeInfo.type === \"redirect-internal\")) {\n                  _context2.next = 134;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 134:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 136:\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script.handleClientScriptLoad)(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                  _context2.next = 149;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context2.next = 147;\n                  break;\n                }\n\n                parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n              case 147:\n                handleHardNavigation({\n                  url: destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 149:\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                _context2.prev = 151;\n                _context2.next = 154;\n                return this.fetchComponent(\"/404\");\n\n              case 154:\n                notFoundRoute = \"/404\";\n                _context2.next = 160;\n                break;\n\n              case 157:\n                _context2.prev = 157;\n                _context2.t3 = _context2[\"catch\"](151);\n                notFoundRoute = \"/_error\";\n\n              case 160:\n                _context2.next = 162;\n                return this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isNotFound: true\n                });\n\n              case 162:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 165:\n                if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n                upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                }); // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n\n                if (!(isQueryUpdating && isErrorRoute)) {\n                  _context2.next = 188;\n                  break;\n                }\n\n                _context2.next = 174;\n                return this.getRouteInfo({\n                  route: this.pathname,\n                  pathname: this.pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n\n              case 174:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 177;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n              case 177:\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                _context2.prev = 178;\n                _context2.next = 181;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 181:\n                _context2.next = 187;\n                break;\n\n              case 183:\n                _context2.prev = 183;\n                _context2.t4 = _context2[\"catch\"](178);\n\n                if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n                }\n\n                throw _context2.t4;\n\n              case 187:\n                return _context2.abrupt(\"return\", true);\n\n              case 188:\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n                if (canSkipUpdating) {\n                  _context2.next = 211;\n                  break;\n                }\n\n                _context2.prev = 192;\n                _context2.next = 195;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 195:\n                _context2.next = 204;\n                break;\n\n              case 197:\n                _context2.prev = 197;\n                _context2.t5 = _context2[\"catch\"](192);\n\n                if (!_context2.t5.cancelled) {\n                  _context2.next = 203;\n                  break;\n                }\n\n                routeInfo.error = routeInfo.error || _context2.t5;\n                _context2.next = 204;\n                break;\n\n              case 203:\n                throw _context2.t5;\n\n              case 204:\n                if (!routeInfo.error) {\n                  _context2.next = 207;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                }\n\n                throw routeInfo.error;\n\n              case 207:\n                if (false) {}\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  this.scrollToHash(as);\n                }\n\n              case 211:\n                return _context2.abrupt(\"return\", true);\n\n              case 214:\n                _context2.prev = 214;\n                _context2.t6 = _context2[\"catch\"](121);\n\n                if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                  _context2.next = 218;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 218:\n                throw _context2.t6;\n\n              case 219:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context3.prev = 7;\n                _context3.next = 10;\n                return this.fetchComponent(\"/_error\");\n\n              case 10:\n                _yield$this$fetchComp = _context3.sent;\n                Component = _yield$this$fetchComp.page;\n                styleSheets = _yield$this$fetchComp.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.prev = 15;\n                _context3.next = 18;\n                return this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context3.sent;\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](15);\n                console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context3.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](7);\n                return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require2, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData, props, cacheKey;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n\n                route = requestedRoute;\n                _context5.prev = 2;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", existingInfo);\n\n              case 7:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n                isBackground = isQueryUpdating;\n                fetchNextDataParams = {\n                  dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: this.isSsr,\n                  parseJSON: true,\n                  inflightCache: isBackground ? this.sbc : this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache,\n                  isBackground: isBackground\n                };\n\n                if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                _context5.t0 = null;\n                _context5.next = 18;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale,\n                  router: this\n                })[\"catch\"](function (err) {\n                  // we don't hard error during query updating\n                  // as it's un-necessary and doesn't need to be fatal\n                  // unless it is a fallback route and the props can't\n                  // be loaded\n                  if (isQueryUpdating) {\n                    return null;\n                  }\n\n                  throw err;\n                });\n\n              case 17:\n                _context5.t0 = _context5.sent;\n\n              case 18:\n                data = _context5.t0;\n\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                  data.effect = undefined;\n                }\n\n                if (isQueryUpdating) {\n                  if (!data) {\n                    data = {\n                      json: self.__NEXT_DATA__.props\n                    };\n                  } else {\n                    data.json = self.__NEXT_DATA__.props;\n                  }\n                }\n\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", data.effect);\n\n              case 24:\n                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                _context5.next = 28;\n                return this.pageLoader.getPageList();\n\n              case 28:\n                pages = _context5.sent;\n\n                if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                route = resolvedRoute;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                  route: route\n                }));\n\n              case 37:\n                if (!(0, _isapiroute.isAPIRoute)(route)) {\n                  _context5.next = 40;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context5.abrupt(\"return\", new Promise(function () {}));\n\n              case 40:\n                _context5.t1 = cachedRouteInfo;\n\n                if (_context5.t1) {\n                  _context5.next = 45;\n                  break;\n                }\n\n                _context5.next = 44;\n                return this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n\n              case 44:\n                _context5.t1 = _context5.sent;\n\n              case 45:\n                routeInfo = _context5.t1;\n\n                if (false) {}\n\n                _require2 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require2.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context5.next = 50;\n                  break;\n                }\n\n                throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n              case 50:\n                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                  delete this.sdc[data.dataHref];\n                }\n\n                _context5.next = 55;\n                return this._getData( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                  var dataHref, fetched;\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context4.next = 8;\n                            break;\n                          }\n\n                          if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                            _context4.next = 3;\n                            break;\n                          }\n\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                          });\n\n                        case 3:\n                          dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                            href: (0, _formaturl.formatWithValidation)({\n                              pathname: pathname,\n                              query: query\n                            }),\n                            asPath: resolvedAs,\n                            locale: locale\n                          });\n                          _context4.next = 6;\n                          return fetchNextData({\n                            dataHref: dataHref,\n                            isServerRender: _this2.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 6:\n                          fetched = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                          });\n\n                        case 8:\n                          _context4.t0 = {};\n                          _context4.next = 11;\n                          return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this2.locales,\n                            defaultLocale: _this2.defaultLocale\n                          });\n\n                        case 11:\n                          _context4.t1 = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            headers: _context4.t0,\n                            props: _context4.t1\n                          });\n\n                        case 13:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n\n              case 55:\n                _yield$this$_getData = _context5.sent;\n                props = _yield$this$_getData.props;\n                cacheKey = _yield$this$_getData.cacheKey;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                  delete this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                this.components[route] = routeInfo;\n                return _context5.abrupt(\"return\", routeInfo);\n\n              case 69:\n                _context5.prev = 69;\n                _context5.t2 = _context5[\"catch\"](2);\n                return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n              case 72:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (asPath === void 0) asPath = url;\n                if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n                if (false) {}\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                urlPathname = parsed.pathname;\n                pathname = parsed.pathname, query = parsed.query;\n                originalPathname = pathname;\n\n                if (false) {}\n\n                _context6.next = 13;\n                return this.pageLoader.getPageList();\n\n              case 13:\n                pages = _context6.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n                _context6.next = 18;\n                return _matchesMiddleware({\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 18:\n                isMiddlewareMatch = _context6.sent;\n\n                if (true) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 22;\n                return (0, _routeloader.getClientBuildManifest)();\n\n              case 22:\n                _yield = _context6.sent;\n                rewrites = _yield.__rewrites;\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 27:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 29:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                if (true) {\n                  _context6.next = 35;\n                  break;\n                }\n\n                _context6.t0 = null;\n                _context6.next = 38;\n                break;\n\n              case 35:\n                _context6.next = 37;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this3.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: originalPathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this3.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this3.sdc,\n                      persistCache: !_this3.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 37:\n                _context6.t0 = _context6.sent;\n\n              case 38:\n                data = _context6.t0;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                  _context6.next = 42;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 42:\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                _context6.next = 45;\n                return this._bfl(asPath, resolvedAs, options.locale, true);\n\n              case 45:\n                if (!_context6.sent) {\n                  _context6.next = 47;\n                  break;\n                }\n\n                this.components[urlPathname] = {\n                  __appRouter: true\n                };\n\n              case 47:\n                _context6.next = 49;\n                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                  }).then(function () {\n                    return false;\n                  })[\"catch\"](function () {\n                    return false;\n                  }) : false;\n                }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n              case 49:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context7.sent;\n                handleCancelled();\n                return _context7.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](1);\n                handleCancelled();\n                throw _context7.t0;\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQSxNQUFNQyxDQUFOOztBQUtBLFNBQVNHLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtFQUMxQixLQUFJLElBQUlDLElBQVIsSUFBZ0JELEdBQWhCO0lBQW9CVCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JPLE1BQXRCLEVBQThCRSxJQUE5QixFQUFvQztNQUNwREMsVUFBVSxFQUFFLElBRHdDO01BRXBEQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBRDtJQUY0QyxDQUFwQztFQUFwQjtBQUlIOztBQUNESCxPQUFPLENBQUNMLE9BQUQsRUFBVTtFQUNiLFdBQVMsb0JBQVc7SUFDaEIsT0FBT1csTUFBUDtFQUNILENBSFk7RUFJYlIsaUJBQWlCLEVBQUUsNkJBQVc7SUFDMUIsT0FBT0Esa0JBQVA7RUFDSCxDQU5ZO0VBT2JDLFNBQVMsRUFBRSxxQkFBVztJQUNsQixPQUFPQSxVQUFQO0VBQ0g7QUFUWSxDQUFWLENBQVA7O0FBV0EsSUFBTVEsd0JBQXdCLEdBQUdDLG1CQUFPLENBQUMsNEdBQUQsQ0FBeEM7O0FBQ0EsSUFBTUMseUJBQXlCLEdBQUdELG1CQUFPLENBQUMsOEdBQUQsQ0FBekM7O0FBQ0EsSUFBTUUsb0JBQW9CLEdBQUdGLG1CQUFPLENBQUMsZ0hBQStCLENBQXBFOztBQUNBLElBQU1HLFlBQVksR0FBR0gsbUJBQU8sQ0FBQyxxRkFBOEIsQ0FBM0Q7O0FBQ0EsSUFBTUksT0FBTyxHQUFHSixtQkFBTyxDQUFDLHlFQUF3QixDQUFoRDs7QUFDQSxJQUFNSyxRQUFRLEdBQUcsYUFBY0oseUJBQXlCLENBQUNLLENBQTFCLENBQTRCTixtQkFBTyxDQUFDLHVFQUF1QixDQUEzRCxDQUEvQjs7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QUFDOFAsTUFBUCxHQUFnQixDQUFDLEdBQUduUCxLQUFLLFdBQVQsR0FBaEI7QUFDSCxDQUZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBudWxsLFxuICAgIGNyZWF0ZUtleTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlcjtcbiAgICB9LFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNNaWRkbGV3YXJlO1xuICAgIH0sXG4gICAgY3JlYXRlS2V5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVtb3ZldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IF9yb3V0ZWxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xuY29uc3QgX3NjcmlwdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvc2NyaXB0XCIpO1xuY29uc3QgX2lzZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcbmNvbnN0IF9kZW5vcm1hbGl6ZXBhZ2VwYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG5jb25zdCBfbm9ybWFsaXplbG9jYWxlcGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbmNvbnN0IF9taXR0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9wYXJzZXJlbGF0aXZldXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xuY29uc3QgX3Jlc29sdmVyZXdyaXRlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG5jb25zdCBfcm91dGVtYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbmNvbnN0IF9yb3V0ZXJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9kZXRlY3Rkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXBhdGhcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmViYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShvcHRpb25zLmFzUGF0aCk7XG4gICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXNQYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWU7XG4gICAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpKTtcbiAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pPT5uZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKSk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfZGVub3JtYWxpemVwYWdlcGF0aC5kZW5vcm1hbGl6ZVBhZ2VQYXRoKShwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSBcIi80MDRcIiB8fCBjbGVhblBhdGhuYW1lID09PSBcIi9fZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZXdyaXRlXCIpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLW1hdGNoZWQtcGF0aFwiKTtcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tYXRjaGVkLXBhdGhcIik7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIl9fbmV4dF9kYXRhX2NhdGNoYWxsXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi9fZXJyb3JcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiLzQwNFwiKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gcGFyYW07XG4gICAgICAgICAgICAgICAgbGV0IGFzID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkoYXMpIHx8ICFyZXdyaXRlSGVhZGVyICYmIHBhZ2VzLmluY2x1ZGVzKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTb3VyY2UgPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHNvdXJjZSkucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgPyB1bmRlZmluZWQgOiBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmV3cml0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBczogcGFyc2VkUmV3cml0ZVRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoc291cmNlKTtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJlZGlyZWN0XCIpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkocmVkaXJlY3RUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtaW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgICBuZXdBczogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2gsXG4gICAgICAgICAgICAgICAgbmV3VXJsOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiBcIm5leHRcIlxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucyk7XG4gICAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgICAgICByZXNwb25zZTogZGF0YS5yZXNwb25zZSxcbiAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgZWZmZWN0XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKipcbiAgICAgKiBUT0RPOiBSZXZpc2l0IHRoaXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBGb3Igbm93IHdlIHdpbGwgbm90IGNvbnNpZGVyIG1pZGRsZXdhcmUgZGF0YSBlcnJvcnMgdG8gYmUgZmF0YWwuXG4gICAgICogbWF5YmUgd2Ugc2hvdWxkIHJldmlzaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKi8gcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxSZXN0b3JhdGlvblwiIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSBcIl9fbmV4dFwiO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHt9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woXCJTU0dfREFUQV9OT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICBcIngtbmV4dGpzLWRhdGFcIjogXCIxXCJcbiAgICAgICAgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHBhcmFtKSB7XG4gICAgbGV0IHsgZGF0YUhyZWYgLCBpbmZsaWdodENhY2hlICwgaXNQcmVmZXRjaCAsIGhhc01pZGRsZXdhcmUgLCBpc1NlcnZlclJlbmRlciAsIHBhcnNlSlNPTiAsIHBlcnNpc3RDYWNoZSAsIGlzQmFja2dyb3VuZCAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gd2hlbiBza2lwcGluZyBjbGllbnQgY2FjaGUgd2Ugd2FpdCB0byB1cGRhdGVcbiAgICAvLyBpbmZsaWdodCBjYWNoZSB1bnRpbCBzdWNjZXNzZnVsIGRhdGEgcmVzcG9uc2VcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gICAgLy8gd2l0aG91dCBibG9ja2luZyBuYXZpZ2F0aW9uIHdoZW4gc3RhbGUgZGF0YSBpcyBhdmFpbGFibGVcbiAgICBpZiAodW5zdGFibGVfc2tpcENsaWVudENhY2hlICYmIHBlcnNpc3RDYWNoZSkge1xuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoaXNCYWNrZ3JvdW5kID8ge1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiXG4gICAgfSA6IHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xufVxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24ocGFyYW0pIHtcbiAgICBsZXQgeyB1cmwgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInB1c2hTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzXG4gICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoY3VyQXMsIFwiaHR0cDovL25cIikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc05vU2xhc2ggIT09ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5jb250YWlucyhjdXJyZW50UGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmwpKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIiArIGRldGVjdGVkRG9tYWluLmRvbWFpbiArICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKFwiXCIgKyAobmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gXCIvXCIgPyBcIlwiIDogYXNOb0Jhc2VQYXRoKSB8fCBcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gXCJyZXBsYWNlU3RhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhdGhuYW1lKSkgOiBwYXRobmFtZTtcbiAgICAgICAgbGV0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoXCIvXCIpICYmICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiSW50ZXJwb2xhdGluZyBocmVmXCIgOiBcIk1pc21hdGNoaW5nIGBhc2AgYW5kIGBocmVmYFwiKSArIFwiIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIFwiICsgKFwidGhlIHBhcmFtczogXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcywgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMsIF9yb3V0ZUluZm9fcHJvcHM7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJvdXRlXCIgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdC5oYW5kbGVDbGllbnRTY3JpcHRMb2FkKShzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvNDA0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi9fZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGVJbmZvX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlSW5mb19yb3V0ZSA6IHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMS5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMxID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wczEucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiYmVmb3JlSGlzdG9yeUNoYW5nZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IGlzUXVlcnlVcGRhdGluZyAmJiAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJiAhcmVhZHlTdGF0ZUNoYW5nZSAmJiAhbG9jYWxlQ2hhbmdlICYmICgwLCBfY29tcGFyZXN0YXRlcy5jb21wYXJlUm91dGVyU3RhdGVzKSh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi9fZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiBcIiwgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZGVmYXVsdCkocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyBcIlwiKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHBhcmFtKSB7XG4gICAgICAgIGxldCB7IHJvdXRlOiByZXF1ZXN0ZWRSb3V0ZSAsIHBhdGhuYW1lICwgcXVlcnkgLCBhcyAsIHJlc29sdmVkQXMgLCByb3V0ZVByb3BzICwgbG9jYWxlICwgaGFzTWlkZGxld2FyZSAsIGlzUHJldmlldyAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAsIGlzUXVlcnlVcGRhdGluZyAsIGlzTWlkZGxld2FyZVJld3JpdGUgLCBpc05vdEZvdW5kICB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgfHwgcGF0aG5hbWUgPT09IFwiLzQwNFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBwYXRobmFtZSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX3Jlc3BvbnNlID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLXNraXBcIik7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzICwgY2FjaGVLZXkgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjXG4gICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSBcIlwiXSA9IGFzLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+d2luZG93LnNjcm9sbFRvKDAsIDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PmlkRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFzUGF0aCA9PT0gdm9pZCAwKSBhc1BhdGggPSB1cmw7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAgICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBjb25zdCB1cmxQYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IGF3YWl0ICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSk7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNQYXRoLCB0aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFyc2VkLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhcnNlZC5wYXRobmFtZSkpKCgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXNQYXRoKS5wYXRobmFtZSkgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCA9PT0gXCJzdHJpY3RcIiA/IG51bGwgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZWRpcmVjdC1leHRlcm5hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xuICAgICAgICAgICAgICAgIF9fYXBwUm91dGVyOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/IFwibG9hZFBhZ2VcIiA6IFwicHJlZmV0Y2hcIl0ocm91dGUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgdGV4dCAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzLmdldFVSTCkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJiB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiYgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2Jsb29tLWZpbHRlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUjtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVI7XG4gICAgICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcywgZHluYW1pY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWFzLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGggPSAoMCwgX3V0aWxzLmdldFVSTCkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbigoKT0+e1xuICAgIFJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcbn0pKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJtYXRjaGVzTWlkZGxld2FyZSIsImNyZWF0ZUtleSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX3Jlc29sdmVocmVmIiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJtYXRjaGVycyIsInBhcnNlUGF0aCIsImFzUGF0aCIsImFzUGF0aG5hbWUiLCJwYXRobmFtZSIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJwYXJhbSIsInJld3JpdGVzIiwiX19yZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZGF0YUhyZWYiLCJlZmZlY3QiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIl9wYXJhbXNfbWV0aG9kIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJfdHJ5VG9QYXJzZUFzSlNPTiIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwiX2JmbF9zIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsImNvbnRhaW5zIiwiX3RoaXNfX2JmbF9zMSIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJzcGxpdCIsImkiLCJjdXJyZW50UGFydCIsImpvaW4iLCJfdGhpc19fYmZsX2QiLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2JmbCIsInNob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsInByZXZMb2NhbGUiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJwYXJzZWQiLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiX19hcHBSb3V0ZXIiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwibWlzc2luZ1BhcmFtcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImlzRXJyb3JSb3V0ZSIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsInBhcnNlZEhyZWYiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwibm90Rm91bmRSb3V0ZSIsImlzTm90Rm91bmQiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMiLCJzdGF0dXNDb2RlIiwiX3JvdXRlSW5mb19wcm9wcyIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfcm91dGVJbmZvX3JvdXRlIiwic2hvdWxkU2Nyb2xsIiwiX29wdGlvbnNfc2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxIiwiX3JvdXRlSW5mb19wcm9wczEiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFzaFJlZ2V4IiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwicmVxdWVzdGVkUm91dGUiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsIl9kYXRhX3Jlc3BvbnNlIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwibG9hZFBhZ2UiLCJjb21wb25lbnRSZXN1bHQiLCJmbiIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});